<%= mcp_apps_sdk_script %>

// MCP Apps SDK initialization
// Auto-detects OpenAI vs Anthropic environments
(function() {
  if (typeof McpExtApps === 'undefined') {
    console.warn('MCP Apps SDK not loaded, falling back to polling');
    return;
  }

  const app = new McpExtApps.App({ name: '<%= app_name_placeholder %> Widget', version: '1.0.0' });
  window._mcpApp = app;

  // Handle tool result - provides widget data
  app.ontoolresult = (result) => {
    window._widgetData = result.structuredContent || result.content?.[0]?.text;
    // Trigger any waiting promises
    if (window._dataResolver) {
      window._dataResolver(window._widgetData);
      window._dataResolver = null;
    }
  };

  // Handle host context changes (theme, etc.)
  app.onhostcontextchanged = (ctx) => {
    if (ctx.theme) {
      window._hostTheme = ctx.theme;
      // Re-apply theme if DarkReader is already initialized
      if (typeof window._applyHostTheme === 'function') {
        window._applyHostTheme(ctx.theme);
      }
    }
  };

  // Connect to host (auto-detects OpenAI vs MCP)
  app.connect().then(() => {
    // Check initial host context for theme
    const ctx = app.getHostContext?.();
    if (ctx?.theme) {
      window._hostTheme = ctx.theme;
    }
  }).catch((err) => {
    console.warn('MCP App connection failed:', err);
  });
})();

function formatDate(dateString) {
  if (!dateString) return "";
  const datePart = dateString.slice(0, 10);
  const [year, month, day] = datePart.split("-").map(Number);
  const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  return `${monthNames[month - 1]} ${day}, ${year}`;
}

function formatDuration(milliseconds) {
  const totalMinutes = Math.floor(milliseconds / 60000);
  const hours = Math.floor(totalMinutes / 60);
  const minutes = totalMinutes % 60;
  if (hours > 0) {
    return minutes > 0 ? `${hours}h ${minutes}m` : `${hours}h`;
  }
  return `${minutes}m`;
}

function formatTime(seconds) {
  if (!seconds || seconds < 0) return "0:00";
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins}:${secs.toString().padStart(2, '0')}`;
}

function formatSetPosition(set, position, asHtml = false) {
  if (!set || !position) return '';
  let abbrev = set;
  if (set.toLowerCase().startsWith('set ')) {
    abbrev = 'S' + set.slice(4);
  } else if (set.toLowerCase() === 'encore') {
    abbrev = 'E';
  } else if (set.toLowerCase().startsWith('encore ')) {
    abbrev = 'E' + set.slice(7);
  }
  const short = `${abbrev}:${position}`;
  if (!asHtml) return short;
  const full = `${set}, Track ${position}`;
  return `<span class="set-position" data-tooltip><span class="set-position-tooltip">${full}</span>${short}</span>`;
}

function escapeHtml(str) {
  if (!str) return '';
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
}

function groupTags(tags) {
  return tags
    .sort((a, b) => (a.priority || 0) - (b.priority || 0) || (a.starts_at_second || 0) - (b.starts_at_second || 0))
    .reduce((acc, tag) => {
      const group = acc[tag.name] || [];
      group.push(tag);
      acc[tag.name] = group;
      return acc;
    }, {});
}

function formatTagTimestamp(seconds) {
  if (!seconds) return null;
  const minutes = Math.floor(seconds / 60);
  const secs = seconds % 60;
  return `${minutes}:${secs.toString().padStart(2, '0')}`;
}

function formatTagTimeRange(tag) {
  if (!tag.starts_at_second && !tag.ends_at_second) return '';
  const start = formatTagTimestamp(tag.starts_at_second);
  const end = formatTagTimestamp(tag.ends_at_second);
  return start && end ? `between ${start} and ${end}` : start ? `at ${start}` : '';
}

function tooltipForTagStack(tagGroup) {
  const hasNotesOrTranscript = tagGroup.some(tag => tag.notes || tag.transcript);
  if (!hasNotesOrTranscript) {
    return tagGroup[0].description || '';
  }
  return tagGroup.map(tag => {
    let timeRange = formatTagTimeRange(tag);
    let tooltipPart = tag.notes ? `${tag.notes} ${timeRange}`.trim() : '';
    return tooltipPart.trim();
  }).filter(Boolean).join(', ');
}

function renderGroupedTagBadges(tags, withTooltips = false) {
  const grouped = groupTags(tags);
  return Object.entries(grouped).map(([tagName, tagGroup]) => {
    const count = tagGroup.length;
    const title = count > 1 ? `${tagName} (${count})` : tagName;
    if (withTooltips) {
      const tooltipText = tooltipForTagStack(tagGroup);
      if (tooltipText) {
        const truncated = tooltipText.length > 100 ? tooltipText.slice(0, 100).trim() + '...' : tooltipText;
        return `<span class="tag-badge" data-tooltip><span class="tag-tooltip">${escapeHtml(truncated)}</span>${escapeHtml(title)}</span>`;
      }
    }
    return `<span class="tag-badge">${escapeHtml(title)}</span>`;
  }).join(withTooltips ? ' ' : '');
}

function truncateText(str, maxLength) {
  if (!str || str.length <= maxLength) return escapeHtml(str);
  return escapeHtml(str.slice(0, maxLength).trim()) + 'â€¦';
}

function parseDuration(durationStr) {
  if (!durationStr) return 0;
  const parts = durationStr.split(':').map(Number);
  if (parts.length === 3) {
    return (parts[0] * 3600 + parts[1] * 60 + parts[2]) * 1000;
  } else if (parts.length === 2) {
    return (parts[0] * 60 + parts[1]) * 1000;
  }
  return 0;
}

const MAX_POLL_ATTEMPTS = 100;
const POLL_INTERVAL_MS = 100;

function getData() {
  // First check if SDK has provided data
  if (window._widgetData) return window._widgetData;
  // Fall back to OpenAI's window.openai for legacy support
  const oa = window.openai || {};
  return oa.toolOutput?.structuredContent 
      || oa.toolOutput 
      || oa.widget?.props 
      || oa.view?.params
      || null;
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function waitForData(isComplete) {
  // If data already available, return immediately
  const existingData = getData();
  if (isComplete(existingData)) return existingData;
  
  // Create a promise that resolves when SDK delivers data
  const sdkPromise = new Promise((resolve) => {
    window._dataResolver = resolve;
    // Timeout after polling period to avoid hanging
    setTimeout(() => {
      if (window._dataResolver === resolve) {
        window._dataResolver = null;
        resolve(null);
      }
    }, MAX_POLL_ATTEMPTS * POLL_INTERVAL_MS);
  });
  
  // Also poll for OpenAI's window.openai as fallback
  const pollingPromise = (async () => {
    for (let i = 0; i < MAX_POLL_ATTEMPTS; i++) {
      const data = getData();
      if (isComplete(data)) return data;
      await sleep(POLL_INTERVAL_MS);
    }
    return getData();
  })();
  
  // Race: whichever delivers data first
  return Promise.race([
    sdkPromise.then((data) => isComplete(data) ? data : pollingPromise),
    pollingPromise
  ]);
}

function setupBackgroundBlur(imageUrl, imgElementId = 'cover-img', blurElementId = 'bg-blur') {
  if (!imageUrl) return;
  
  const bgEl = document.getElementById(blurElementId);
  if (!bgEl) return;

  const applyBlur = () => {
    bgEl.style.backgroundImage = `url("${imageUrl}")`;
    const playerBlur = document.getElementById('player-blur');
    if (playerBlur) {
      playerBlur.style.backgroundImage = `url("${imageUrl}")`;
    }
  };

  const coverImg = document.getElementById(imgElementId);
  if (coverImg && !coverImg.complete) {
    coverImg.onload = applyBlur;
  } else {
    applyBlur();
  }
}

function initExpandButton() {
  const expandBtn = document.getElementById('expand-btn');
  const card = document.querySelector('.card');
  if (!expandBtn || !card) return;

  expandBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    card.classList.toggle('expanded');
    expandBtn.title = card.classList.contains('expanded') ? 'Collapse' : 'Expand';
  });
}

function showToast(message) {
  const toast = document.getElementById('toast');
  if (!toast) return;
  toast.textContent = message;
  toast.classList.add('visible');
  setTimeout(() => {
    toast.classList.remove('visible');
  }, 2000);
}

function showCopiedFeedback() {
  showToast("URL copied to clipboard");
}

function fallbackCopyToClipboard(text, onSuccess) {
  const textArea = document.createElement("textarea");
  textArea.value = text;
  textArea.style.position = "fixed";
  textArea.style.left = "-9999px";
  textArea.style.top = "0";
  document.body.appendChild(textArea);
  textArea.focus();
  textArea.select();
  try {
    document.execCommand("copy");
    if (onSuccess) onSuccess();
  } catch (err) {
    showToast("Failed to copy URL");
  }
  document.body.removeChild(textArea);
}

function copyToClipboard(url) {
  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(url)
      .then(() => showCopiedFeedback())
      .catch(() => fallbackCopyToClipboard(url, showCopiedFeedback));
  } else {
    fallbackCopyToClipboard(url, showCopiedFeedback);
  }
}

function renderToast() {
  return `<div class="toast" id="toast"></div>`;
}

const DARK_READER_CONFIG = {
  brightness: 100,
  contrast: 90,
  sepia: 10,
  css: `
    /* Audio player is already dark themed - protect from Dark Reader */
    .audio-player {
      filter: none !important;
      -webkit-filter: none !important;
    }
    .player-blur-wrapper {
      background: #1a1a1c !important;
      background-color: #1a1a1c !important;
      filter: none !important;
      -webkit-filter: none !important;
    }
    .player-blur {
      filter: blur(55px) saturate(1.2) !important;
      -webkit-filter: blur(55px) saturate(1.2) !important;
      opacity: 0.5 !important;
    }
    .player-blur::after {
      background: rgba(20, 20, 22, 0.65) !important;
      background-color: rgba(20, 20, 22, 0.65) !important;
      filter: none !important;
      -webkit-filter: none !important;
    }
    
    /* Preserve scrubber styling */
    .scrubber-container {
      isolation: isolate !important;
    }
    .scrubber-container,
    .scrubber-container::before,
    .progress-overlay {
      filter: none !important;
      -webkit-filter: none !important;
      mix-blend-mode: normal !important;
    }
    .scrubber-container::before {
      background: rgba(255, 255, 255, 0.35) !important;
      background-color: rgba(255, 255, 255, 0.35) !important;
    }
    
    /* Player text colors */
    .player-track-title {
      color: rgba(255, 255, 255, 0.95) !important;
    }
    .player-track-subtitle,
    .player-track-subtitle .player-link,
    .player-track-subtitle .location-link {
      color: rgba(255, 255, 255, 0.75) !important;
    }
    .time-display {
      color: rgba(255, 255, 255, 0.7) !important;
    }
    .skip-btn,
    .scrub-btn {
      color: rgba(255, 255, 255, 0.7) !important;
    }
    .player-close-btn {
      color: rgba(255, 255, 255, 0.6) !important;
    }
    
    /* Preserve play button styling - player is already dark themed */
    .audio-player .play-pause-btn,
    .card .play-pause-btn,
    .card:not(.audio-playing) .play-pause-btn {
      background: rgba(255, 255, 255, 0.15) !important;
      background-color: rgba(255, 255, 255, 0.15) !important;
      filter: none !important;
      -webkit-filter: none !important;
    }
    .audio-player.audio-playing .play-pause-btn,
    .card.audio-playing .play-pause-btn,
    .card.audio-playing .audio-player .play-pause-btn {
      background: #5bcefa !important;
      background-color: #5bcefa !important;
      filter: none !important;
      -webkit-filter: none !important;
    }
    .play-pause-btn svg,
    .play-pause-btn .play-icon,
    .play-pause-btn .pause-icon {
      fill: white !important;
      color: white !important;
    }
    
    /* Preserve cover play button */
    .cover-play-button {
      filter: none !important;
      -webkit-filter: none !important;
    }
    .cover-play-button:hover {
      background: rgba(3, 187, 242, 0.7) !important;
    }
    .cover-play-button svg {
      fill: rgba(255, 255, 255, 0.95) !important;
    }
    
    /* Preserve blue border animation when playing */
    .audio-player.audio-playing .player-content::after,
    .card.audio-playing::before {
      filter: none !important;
      -webkit-filter: none !important;
    }
    
    /* Preserve hover colors */
    .player-track-subtitle .player-link:hover,
    .player-track-subtitle .location-link:hover,
    .skip-btn:hover:not(:disabled),
    .scrub-btn:hover:not(:disabled) {
      color: #5bcefa !important;
    }
    .player-close-btn:hover {
      color: rgba(255, 255, 255, 0.9) !important;
    }
    .show-date-link:hover,
    .location-link:hover,
    .playlist-name a:hover,
    .playlist-description:hover,
    .show-meta-item.clickable:hover,
    .track-menu-btn:hover {
      color: #03BBF2 !important;
    }
    
    /* Preserve tooltip styling */
    .tag-tooltip,
    .set-position-tooltip {
      background-color: #515152 !important;
      color: white !important;
      filter: none !important;
      -webkit-filter: none !important;
    }
    .tag-tooltip::before,
    .set-position-tooltip::before {
      background-color: #515152 !important;
      filter: none !important;
      -webkit-filter: none !important;
    }
    
    /* Preserve blue tag hover */
    .track-inline-tags .tag-badge:hover {
      background-color: rgba(3, 187, 242, 0.2) !important;
      color: #03BBF2 !important;
    }
    
    /* Preserve cover art hover glow */
    .cover-art-container.clickable:hover .cover-art {
      box-shadow: 0 4px 16px rgba(3, 187, 242, 0.4) !important;
    }
  `
};

function getColorScheme() {
  // Check SDK-provided theme first
  if (window._hostTheme) return window._hostTheme;
  
  // Check MCP App context
  if (window._mcpApp?.getHostContext) {
    const ctx = window._mcpApp.getHostContext();
    if (ctx?.theme) return ctx.theme;
  }
  
  // Fall back to OpenAI's window.openai
  const oa = window.openai || {};
  const scheme = oa.appearance?.colorScheme
    || oa.view?.appearance?.colorScheme
    || oa.theme?.colorScheme;
  if (scheme) return scheme;

  // Fall back to system preference
  if (window.matchMedia?.('(prefers-color-scheme: dark)').matches) {
    return 'dark';
  }
  return 'light';
}

function initDarkMode() {
  if (typeof DarkReader === 'undefined') return;

  DarkReader.setFetchMethod(window.fetch);

  const applyTheme = (scheme) => {
    if (scheme === 'dark') {
      DarkReader.enable(DARK_READER_CONFIG);
    } else {
      DarkReader.disable();
    }
  };

  // Expose for MCP Apps SDK host context changes
  window._applyHostTheme = applyTheme;

  applyTheme(getColorScheme());

  const mediaQuery = window.matchMedia?.('(prefers-color-scheme: dark)');
  if (mediaQuery?.addEventListener) {
    mediaQuery.addEventListener('change', (e) => {
      // Don't override if host explicitly set a theme
      if (window._hostTheme) return;
      
      const oa = window.openai || {};
      const explicitScheme = oa.appearance?.colorScheme
        || oa.view?.appearance?.colorScheme
        || oa.theme?.colorScheme;
      if (!explicitScheme) {
        applyTheme(e.matches ? 'dark' : 'light');
      }
    });
  }
}

initDarkMode();

